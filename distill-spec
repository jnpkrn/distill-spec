#!/usr/bin/env python
# Copyright 2015 Red Hat, Inc.
# Part of distill-spec project (emerged from clufter)
# Licensed under GPLv2+ (a copy included | http://gnu.org/licenses/gpl-2.0.txt)

# Script to distill plain specfile from meta (but still usable!) specfile.
#
# TODO:
# - skip-prefix -> semi-preprocessed, e.g., keeping if-else-endif, etc.

from base64 import (urlsafe_b64encode as b64encode,
                    urlsafe_b64decode as b64decode)
from ctypes import cdll, c_char_p, c_int, c_void_p
from getopt import GetoptError, getopt
from re import compile as re_compile, escape as re_escape, X as re_X
from sys import argv, stdin
from tempfile import NamedTemporaryFile

from rpm import RPMSPEC_ANYARCH, RPMSPEC_FORCE, RPMBUILD_NONE, _rpmb, addMacro


PREFIX = "distill-spec-prefix:"


# ctypes magic

rpmb = cdll[_rpmb.__file__]

rpmSpecParse          = rpmb.rpmSpecParse
rpmSpecParse.argtypes = [c_char_p, c_int, c_void_p]
rpmSpecParse.restype  = c_void_p

rpmSpecGetSection          = rpmb.rpmSpecGetSection
rpmSpecGetSection.argtypes = [c_void_p, c_int]
rpmSpecGetSection.restype  = c_char_p


# re stuff

# temporary wrapping must start with '_' or '/' because of Requires context:
# error: line 87:
# Dependency tokens must begin with alpha-numeric, '_' or '/':
# Requires:       @@_bindir@@/nano
neutral_mark = "_._"
nm_parens = ((neutral_mark, ) * 2)
nm_parens_re = ((re_escape(neutral_mark), ) * 2)

# see rpm/lib/relocation.c
fragile = 'name', 'version', 'release'
fragile_upper = tuple(f.upper() for f in fragile)

re_noexpand_fragile = re_compile("""(?<!%)
                                      %({{)?
                                        (?P<g>(?:!?\?)?
                                          (?P<m>(?:{0}))
                                        )
                                        (?=\W)
                                      (?(1)}})""".format('|'.join(fragile)),
                                 re_X)
re_noexpand = lambda e: re_compile("""(?<!%)
                                        %({{)?
                                          (?!
                                            (?:!?\?)?
                                              (?:
                                                clufter\w*

                                                #see rpm/rpmio/macro.c

                                                |load|global|define|undefine
                                                |echo|warn|error
                                                |trace|dump|lua

                                                |basename|dirname|suffix
                                                |expand|verbose|uncompress
                                                |url2path|u2p|getenv|getconfdir
                                                #|S|P|F

                                                |SOURCE|PATCH

                                                |bcond_with(?:out)?|with[ ]


                                                # see rpm/build/parseSpec.c

                                                |if|else|endif

                                                |package|description|files
                                                |changelog

                                                |prep|build|install|check|clean

                                                |pre(?:un|trans)?
                                                |post(?:un|trans)?
                                                |trigger(?:postun|prein|un|in)?

                                                |verifyscript|sepolicy


                                                # see rpm/build/parsePrep.c

                                                |prep
                                                |setup


                                                # see rpm/build/files.c

                                                |attr|defattr
                                                |dev

                                                |dir|docdir
                                                |doc|license|readme
                                                |pubkey
                                                |ghost

                                                |caps
                                                |config
                                                |lang

                                                |exclude
                                                |verify|defverify

                                              )
                                            \W)
                                            (?P<g>(?:!?\?)?(?P<m>[^:%{{(\s}}]+))
                                        (?(1)}})""".format('|'.join(
                                            (i + '\w+') for i in e
                                        )),
                         re_X)
re_nonexpmacro_wrapped = re_compile("(?P<m>\S*?)".join(nm_parens_re))
re_multiline = re_compile('\n\n+')


def get_parsed(f):
    spec = rpmSpecParse(f, RPMSPEC_ANYARCH | RPMSPEC_FORCE, 0)
    s = rpmSpecGetSection(spec, RPMBUILD_NONE)
    return s

#def add_macro(name, spec):
#    print "adding:", name, '=', spec, restore_macros(spec).join(('(', ')'))
#    addMacro(name, spec)


def redef_macros(f, expand=(), skip_prefix=False):
    s = None
    with open(f, 'r') as fo:
        s = fo.read()
    if not skip_prefix:
        expand, startpos = list(expand), 0
        while True:
            newpos = s.find(PREFIX, startpos)
            if newpos == -1:
                break
            newpos += len(PREFIX)
            startpos = s.find("\n", )
            if startpos == -1:
                break
            expand.append(s[newpos:startpos].strip())
    s = re_noexpand(expand).sub(
            lambda m: addMacro(m.group('m'), b64encode(m.group(0))
                               .replace('=', '+').join(nm_parens))
                      or m.group(0),
            re_noexpand_fragile.sub(lambda m: m.group(0).upper(),
                                    s#.replace("%%{", "%%%%{")
                                    )
    )
    with open(f, 'w') as fo:
        fo.write(s)
    return f


def restore_macros(s):
    return re_nonexpmacro_wrapped.sub(lambda m: "{0}".format(
                                          tuple(
                                              n.lower() if any(f in n for f
                                                               in fragile_upper)
                                              else n for n in (b64decode(
                                                  m.group('m').replace('+', '=')
                                              ), )
                                          )[0]),
                                      s)


def squeeze_newlines(s):
    #return re_multiline.sub('\n\n', s).lstrip('\n')
    return '\n'.join(reduce(
        lambda prev, new: prev[:-1] + [new] if not prev[-1]
                          and (prev[-2].split(':', 1)[0] == new.split(':', 1)[0]
                               or not prev[-2])
                          else prev + [new], s.splitlines(), ['', '']
    )[1:])


if __name__ == "__main__":
    opts, args, expand, skip_prefix = [], [], [], False
    try:
        opts, args = getopt(argv[1:], "d:e:s",
                            ("define=", "expand=", "skip-prefix"))
    except GetoptError:
         pass
    for o, a in opts:
        if o in ("-d", "--define"):
            addMacro(*tuple(i.strip() for i in a.split(' ', 1)))
        elif o in ("-e", "--expand"):
            expand.append(a)
        elif o in ("-s", "--skip-prefix"):
            skip_prefix = True
    f = args[0] if args else stdin
    if f is not stdin:
        f = open(f, 'r')
    s = f.read()
    if f is not stdin:
        f.close()
    with NamedTemporaryFile('w') as f:
        f.write(s)
        f.flush()
        f.seek(0)
        # first redefine macros in following way:
        # 1. replace name, version, ... with upper-cased version, because
        #    the are the automatic macros that's get (re)defined when parsing
        #    the specfile -- this way we can preserve them in combinarion w/ 2.
        # 2. redefine macros to be preserved (i.e., not native directives/tags
        #    and clufter* macros that we wan't to expand right now) with
        #    base64-encoded original macro declaration (i.e., with initial
        #    question mark, etc.) so that it will be replaced like this
        #    in the specfile preprocessing phase (XXX why not to replace it
        #    right away then?)
        #s = open(redef_macros(f.name), expand, skip_prefix).read()
        # second, preprocess the specfile (with new macros)
        #s = get_parsed(redef_macros(f.name, expand, skip_prefix))
        # third, restore those now base64-encoded macros
        #s = restore_macros(get_parsed(redef_macros(f.name, expand,
        #                                           skip_prefix)))
        # fourth, smart-squeeze the newlines (2+ x \n --> 2 x \n, ...)
        s = squeeze_newlines(
            restore_macros(
                get_parsed(
                    redef_macros(f.name, expand, skip_prefix)
                )
            )
        )
    print s
